#ifndef _ClarityTool_h_
#define _ClarityTool_h_

#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"

#include "canvas/Persistency/Common/FindManyP.h"

#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "lardata/RecoBaseProxy/ProxyBase.h"

#include "CommonFunctions/Pandora.h"
#include "CommonFunctions/Scatters.h"
#include "CommonFunctions/Corrections.h"
#include "CommonFunctions/Region.h"
#include "CommonFunctions/Types.h"

#include "art/Utilities/ToolMacros.h"
#include "art/Utilities/make_tool.h"

#include "SignatureTools/SignatureToolBase.h"
#include "SignatureTools/VertexToolBase.h"

#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"

#include "TDatabasePDG.h"

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <cmath>
#include <chrono>

namespace claritytools {

 std::vector<bool> _bad_channel_mask;
 const std::string _bad_channel_file =  "badchannels.txt";
 const double _patt_hit_comp_thresh =  0.5;
 const int _patt_hit_thresh = 100;
 const double _sig_hit_comp_thresh = 0.1;
 const int _chan_act_reg = 3;
 const double _hit_exclus_thresh = 0.5;
 const double _sig_exclus_thresh = 0.8;
 const int _targetDetectorPlane = 0;
 const geo::GeometryCore* _geo = art::ServiceHandle<geo::Geometry>()->provider();;

void LoadBadChannels(){

    size_t num_channels = _geo->Nchannels();
    _bad_channel_mask.resize(num_channels, false);

    if (!_bad_channel_file.empty()) {
        cet::search_path sp("FW_SEARCH_PATH");
        std::string fullname;
        sp.find_file(_bad_channel_file, fullname);
        if (fullname.empty()) 
            throw cet::exception("PatternClarityFilter") << "-- Bad channel file not found: " << _bad_channel_file;

        std::ifstream inFile(fullname, std::ios::in);
        std::string line;
        while (std::getline(inFile, line)) {
            if (line.find("#") != std::string::npos) continue;
            std::istringstream ss(line);
            int ch1, ch2;
            ss >> ch1;
            if (!(ss >> ch2)) ch2 = ch1;
            for (int i = ch1; i <= ch2; ++i) {
                _bad_channel_mask[i] = true;
            }
        }
    }

}

bool filterPatternCompleteness(art::Event &e, signature::Pattern& patt, const std::vector<art::Ptr<recob::Hit>> mc_hits, const std::unique_ptr<art::FindManyP<simb::MCParticle, anab::BackTrackerHitMatchingData>>& mcp_bkth_assoc)
{
    std::unordered_map<int, int> sig_hit_map;
    double tot_patt_hit = 0; 

    std::vector<art::Ptr<recob::Hit>> patt_hits;
    for (const auto& sig : patt) {
        for (const auto& mcp_s : sig) {
            double sig_hit = 0;

            for (const auto& hit : mc_hits) {
                auto assmcp = mcp_bkth_assoc->at(hit.key());
                auto assmdt = mcp_bkth_assoc->data(hit.key());

                for (unsigned int ia = 0; ia < assmcp.size(); ++ia){
                    auto amd = assmdt[ia];
                    if (assmcp[ia]->TrackId() == mcp_s->TrackId() && amd->isMaxIDEN == 1) {
                        patt_hits.push_back(hit);
                        sig_hit += 1; 
                    }
                }
            }

            sig_hit_map[mcp_s->TrackId()] += sig_hit;
            tot_patt_hit += sig_hit;
        }
    }

    if (mc_hits.empty() || patt_hits.empty()) 
        return false;

    double patt_comp = static_cast<double>(patt_hits.size()) / mc_hits.size();
    std::cout << "Pattern completeness " << patt_comp << std::endl;
    std::cout << "Total pattern hits " << tot_patt_hit << std::endl;
    if (patt_comp < _patt_hit_comp_thresh || tot_patt_hit < _patt_hit_thresh)
        return false;

    for (const auto& [_, num_hits] : sig_hit_map) 
    {
        std::cout << "Signature hit " << num_hits << std::endl;
        if (num_hits / tot_patt_hit < _sig_hit_comp_thresh) 
            return false;       
    }

    return true;
}

bool filterSignatureIntegrity(art::Event &e, signature::Pattern& patt, const std::vector<art::Ptr<recob::Hit>> mc_hits, const std::unique_ptr<art::FindManyP<simb::MCParticle, anab::BackTrackerHitMatchingData>>& mcp_bkth_assoc)
{
    auto isChannelRegionActive = [&](const TVector3& point) -> bool {
        for (geo::PlaneID const& plane : _geo->IteratePlaneIDs()) {
            try {
                geo::WireID wire = _geo->NearestWireID(point, plane);
                raw::ChannelID_t central_channel = _geo->PlaneWireToChannel(wire);

                for (int offset = -_chan_act_reg; offset <= _chan_act_reg; ++offset) {
                    raw::ChannelID_t neighboring_channel = central_channel + offset;

                    if (neighboring_channel < 0 || static_cast<size_t>(neighboring_channel) >= _geo->Nchannels())
                        continue; 

                    if (_bad_channel_mask[neighboring_channel])
                        return false; 
                }
            } catch (const cet::exception&) {
                return false; 
            }
        }
        return true;
    };

    for (const auto& sig : patt) {
        for (const auto& mcp_s : sig) {
            TVector3 start(mcp_s->Vx(), mcp_s->Vy(), mcp_s->Vz());
            if (!isChannelRegionActive(start))
                return false;

            if (std::abs(mcp_s->PdgCode()) != 13) { 
                TVector3 end(mcp_s->EndX(), mcp_s->EndY(), mcp_s->EndZ());
                if (!isChannelRegionActive(end))
                    return false;
            }
        }
    }

    return true;
}

bool filterHitExclusivity(art::Event &e, signature::Pattern& patt, const std::vector<art::Ptr<recob::Hit>> mc_hits, const std::unique_ptr<art::FindManyP<simb::MCParticle, anab::BackTrackerHitMatchingData>>& mcp_bkth_assoc)
{
    for (const auto& sig : patt) {
        double sig_q_inclusive = 0.0;
        double sig_q_exclusive = 0.0;
        for (const auto& mcp_s : sig) {
            for (const auto& hit : mc_hits) {
                auto assmcp = mcp_bkth_assoc->at(hit.key());
                auto assmdt = mcp_bkth_assoc->data(hit.key());

                for (unsigned int ia = 0; ia < assmcp.size(); ++ia){
                    auto amd = assmdt[ia];
                    if (assmcp[ia]->TrackId() == mcp_s->TrackId()) {
                        sig_q_inclusive += amd->numElectrons * amd->ideNFraction;
                        if (amd->ideNFraction > _hit_exclus_thresh) 
                            sig_q_exclusive += amd->numElectrons * amd->ideNFraction;
                    }
                }
            }
        }

        if (sig_q_exclusive / sig_q_inclusive < _sig_exclus_thresh)
            return false;
    }

    return true;
}

}

#endif
